//
// Copyright 2021 The Sigstore Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

//! Strucs providing cosign capabilities

use anyhow::{anyhow, Result};
use async_trait::async_trait;
use std::collections::HashMap;
use x509_parser::{traits::FromDer, x509::SubjectPublicKeyInfo};

use crate::crypto::{self, CosignVerificationKey};
use crate::registry::{Auth, ClientConfig};
use crate::simple_signing::SimpleSigning;

mod signature_layers;
use self::signature_layers::{build_signature_layers, SignatureLayer};

mod bundle;

pub(crate) const SIGSTORE_OCI_MEDIA_TYPE: &str = "application/vnd.dev.cosign.simplesigning.v1+json";
pub(crate) const SIGSTORE_SIGNATURE_ANNOTATION: &str = "dev.cosignproject.cosign/signature";
pub(crate) const SIGSTORE_BUNDLE_ANNOTATION: &str = "dev.sigstore.cosign/bundle";
pub(crate) const SIGSTORE_CERT_ANNOTATION: &str = "dev.sigstore.cosign/certificate";

#[async_trait]
/// Cosign Abilities that have to be implemented by a
/// Cosign client
pub trait CosignCapabilities {
    /// Calculate the cosign image reference.
    /// This is the location cosign stores signatures.
    async fn triangulate(&mut self, image: &str, auth: &Auth) -> Result<(String, String)>;

    /// Ensure the provided key is used to sign at least one of the layers of the
    /// signature image produced by cosign.
    ///
    /// Returns the list of SimpleSigning objects that have been signed by the given
    /// key.
    async fn verify(
        &mut self,
        auth: &Auth,
        source_image_digest: &str,
        cosign_image: &str,
        public_key: &Option<String>,
        annotations: Option<HashMap<String, String>>,
    ) -> Result<Vec<SimpleSigning>>;
}

/// Cosign Client
///
/// Given a container image/oci artifact, calculate the location of
/// its cosign signature inside of a registry:
///
/// ```rust,no_run
/// use crate::sigstore::cosign::CosignCapabilities;
/// use std::io::prelude::*;
/// use std::fs::File;
///
/// #[tokio::main]
/// pub async fn main() {
///   let auth = &sigstore::registry::Auth::Anonymous;
///
///   // Read the rekor key from the location generated by `cosign init`
///   let mut rekor_pub_key_file = File::open("~/.sigstore/root/targets/rekor.pub")
///     .expect("Cannot read rekor public key");
///   let mut rekor_pub_key = String::new();
///   rekor_pub_key_file.read_to_string(&mut rekor_pub_key)
///     .expect("Not a ECDSA PEM encoded key");
///
///   let mut client = sigstore::cosign::ClientBuilder::default()
///     .with_rekor_pub_key(&rekor_pub_key)
///     .build()
///     .expect("Unexpected failure while building Client");
///   let image = "registry-testing.svc.lan/kubewarden/disallow-service-nodeport:v0.1.0";
///   let (cosign_signature_image, source_image_digest) = client.triangulate(
///     image,
///     auth
///   ).await.expect("Unexpected failure while using triangulate");
/// }
/// ```
///
/// Verify the signature of a container image/oci artifact:
///
/// ```rust,no_run
/// use crate::sigstore::cosign::CosignCapabilities;
/// use std::collections::HashMap;
/// use std::io::prelude::*;
/// use std::fs::File;
///
/// #[tokio::main]
/// pub async fn main() {
///   let auth = &sigstore::registry::Auth::Anonymous;
///
///   // Read the rekor key from the location generated by `cosign init`
///   let mut rekor_pub_key_file = File::open("~/.sigstore/root/targets/rekor.pub")
///     .expect("Cannot read rekor public key");
///   let mut rekor_pub_key = String::new();
///   rekor_pub_key_file.read_to_string(&mut rekor_pub_key)
///     .expect("Not a ECDSA PEM encoded key");
///
///   let mut client = sigstore::cosign::ClientBuilder::default()
///     .with_rekor_pub_key(&rekor_pub_key)
///     .build()
///     .expect("Unexpected failure while building Client");
///
///   // Obtained via `triangulate`
///   let cosign_image = "registry-testing.svc.lan/kubewarden/disallow-service-nodeport:sha256-5f481572d088dc4023afb35fced9530ced3d9b03bf7299c6f492163cb9f0452e.sig";
///   // Obtained via `triangulate`
///   let source_image_digest = "sha256-5f481572d088dc4023afb35fced9530ced3d9b03bf7299c6f492163cb9f0452e";
///
///   let mut annotations: HashMap<String, String> = HashMap::new();
///   annotations.insert("env".to_string(), "prod".to_string());
///
///   let verification_key = String::from("contents of a `cosign.pub` key read from the disk");
///   let signatures_matching_requirements = client.verify(
///     auth,
///     cosign_image,
///     source_image_digest,
///     &Some(verification_key),
///     Some(annotations)
///   ).await.expect("unexpected verification error");
///
///   if signatures_matching_requirements.is_empty() {
///     panic!("no signature is matching the requirments");
///   } else {
///     println!("signatures matching the requirements: {:?}",
///         signatures_matching_requirements);
///   }
/// }
/// ```
pub struct Client {
    registry_client: Box<dyn crate::registry::ClientCapabilities>,
    rekor_pub_key: CosignVerificationKey,
    fulcio_pub_key_raw: Vec<u8>,
    cert_email: Option<String>,
}

/// A builder that generates Client objects.
///
/// **Note well:** the public key of Rekor instance used when
/// signing the artifact must be provided via the `with_rekor_pub_key`
/// method.
///
/// Currently this library is not able to retrieve the key from Sigstore's
/// TUF repository like `cosign` does. This will be done in the near future.
///
/// In the meantime, end users of the library can fetch the key in a secure
/// way by using `cosign init`.
/// This will place the key under `~/.sigstore/root/targets/rekor.pub`.
pub struct ClientBuilder {
    client_config: ClientConfig,
    rekor_pub_key: Option<String>,
    fulcio_cert: Option<Vec<u8>>,
    cert_email: Option<String>,
}

impl Default for ClientBuilder {
    fn default() -> Self {
        ClientBuilder {
            client_config: ClientConfig::default(),
            rekor_pub_key: None,
            fulcio_cert: None,
            cert_email: None,
        }
    }
}

impl ClientBuilder {
    pub fn with_rekor_pub_key(mut self, key: &str) -> Self {
        self.rekor_pub_key = Some(key.to_string());
        self
    }

    pub fn with_fulcio_cert(mut self, cert: &[u8]) -> Self {
        self.fulcio_cert = Some(cert.to_owned());
        self
    }

    pub fn with_client_config(mut self, config: ClientConfig) -> Self {
        self.client_config = config;
        self
    }

    pub fn with_cert_email(mut self, cert_email: Option<&str>) -> Self {
        self.cert_email = cert_email.map(String::from);
        self
    }

    pub fn build(self) -> Result<Client> {
        if self.rekor_pub_key.is_none() {
            return Err(anyhow!("The rekor public key has not been provided"));
        }
        let rekor_pub_key_raw = self.rekor_pub_key.clone().unwrap();
        let rekor_pub_key = crypto::new_verification_key(&rekor_pub_key_raw)?;

        let cert_email = self.cert_email.clone();

        let oci_client = oci_distribution::client::Client::new(self.client_config.clone().into());
        Ok(Client {
            registry_client: Box::new(crate::registry::OciClient {
                registry_client: oci_client,
            }),
            rekor_pub_key,
            fulcio_pub_key_raw: self.extract_fulcio_public_key()?,
            cert_email,
        })
    }

    fn extract_fulcio_public_key(self) -> Result<Vec<u8>> {
        match self.fulcio_cert {
            Some(cert) => crypto::extract_public_key_from_pem_cert(&cert),
            None => Err(anyhow!("The fulcio cert has not been provided")),
        }
    }
}

#[async_trait]
impl CosignCapabilities for Client {
    async fn triangulate(&mut self, image: &str, auth: &Auth) -> Result<(String, String)> {
        let image_reference: oci_distribution::Reference = image
            .parse()
            .map_err(|e| anyhow!("Cannot parse image reference '{}': {:?}", image, e))?;

        let manifest_digest = self
            .registry_client
            .fetch_manifest_digest(&image_reference, &auth.into())
            .await
            .map_err(|e| {
                anyhow!(
                    "Cannot fetch manifest digest for {:?}: {:?}",
                    image_reference,
                    e
                )
            })?;

        let sign = format!(
            "{}/{}:{}.sig",
            image_reference.registry(),
            image_reference.repository(),
            manifest_digest.replace(":", "-")
        );
        let reference = sign
            .parse()
            .map_err(|e| anyhow!("Cannot calculate signature object reference {:?}", e))?;

        Ok((reference, manifest_digest))
    }

    async fn verify(
        &mut self,
        auth: &Auth,
        source_image_digest: &str,
        cosign_image: &str,
        public_key: &Option<String>,
        annotations: Option<HashMap<String, String>>,
    ) -> Result<Vec<SimpleSigning>> {
        let (manifest, layers) = self.fetch_manifest_and_layers(auth, cosign_image).await?;

        let (_, fulcio_pub_key) = SubjectPublicKeyInfo::from_der(&self.fulcio_pub_key_raw)
            .map_err(|e| anyhow!("Cannot parse fulcio public key: {:?}", e))?;

        let verification_key: Option<CosignVerificationKey> = match public_key {
            Some(key) => Some(crate::crypto::new_verification_key(key)?),
            None => None,
        };

        let signature_layers = build_signature_layers(
            &manifest,
            &layers,
            &self.rekor_pub_key,
            fulcio_pub_key,
            self.cert_email.as_ref(),
        );

        let verified_signatures = self.find_simple_signing_objects_satisfying_constraints(
            &signature_layers,
            source_image_digest,
            verification_key.as_ref(),
            &annotations.unwrap_or_default(),
        );
        Ok(verified_signatures)
    }
}

impl Client {
    /// Internal helper method used to fetch data from an OCI registry
    async fn fetch_manifest_and_layers(
        &mut self,
        auth: &Auth,
        cosign_image: &str,
    ) -> Result<(
        oci_distribution::manifest::OciManifest,
        Vec<oci_distribution::client::ImageLayer>,
    )> {
        let cosign_image_reference: oci_distribution::Reference = cosign_image
            .parse()
            .map_err(|e| anyhow!("Cannot parse image reference '{}': {:?}", cosign_image, e))?;
        let oci_auth: oci_distribution::secrets::RegistryAuth = auth.into();

        let (manifest, _) = self
            .registry_client
            .pull_manifest(&cosign_image_reference, &oci_auth)
            .await
            .map_err(|e| {
                anyhow!(
                    "Cannot pull manifest for image {:?}: {:?}",
                    cosign_image_reference,
                    e
                )
            })?;
        let image_data = self
            .registry_client
            .pull(
                &cosign_image_reference,
                &oci_auth,
                vec![SIGSTORE_OCI_MEDIA_TYPE],
            )
            .await
            .map_err(|e| {
                anyhow!(
                    "Cannot pull data for image {:?}: {:?}",
                    cosign_image_reference,
                    e
                )
            })?;

        Ok((manifest, image_data.layers))
    }

    /// The heart of the verification code. This is where all the checks are done
    /// against the SignatureLayer objects found inside of the OCI registry.
    ///
    /// The method returns a list of SimpleSigning object satisfying the requirements.
    /// The list is empty if no SimpleSigning object satisfied the requirements.
    fn find_simple_signing_objects_satisfying_constraints(
        &self,
        signature_layers: &[SignatureLayer],
        source_image_digest: &str,
        verification_key: Option<&CosignVerificationKey>,
        annotations: &HashMap<String, String>,
    ) -> Vec<SimpleSigning> {
        let verified_signatures: Vec<SimpleSigning> = signature_layers
            .iter()
            .filter_map(|sl| {
                // find all the layers that have a signature that
                // can be either verified with the supplied verification_key
                // or with of the trusted bundled certificates.
                // Then convert them into SimpleSigning objects
                if sl.verified(verification_key) {
                    Some(sl.simple_signing.clone())
                } else {
                    None
                }
            })
            .filter(|ss| {
                // ensure given annotations are respected
                ss.satisfies_annotations(annotations)
            })
            .filter(|ss| {
                // ensure the manifest digest mentioned by the signed SimpleSigning
                // object matches the value of the OCI object we're verifying
                ss.satisfies_manifest_digest(source_image_digest)
            })
            .collect();
        verified_signatures
    }
}

#[cfg(test)]
mod tests {
    use self::signature_layers::tests::build_correct_signature_layer_without_bundle;
    use super::*;
    use crate::{
        crypto::{self, extract_public_key_from_pem_cert},
        mock_client::test::MockOciClient,
    };

    pub(crate) const REKOR_PUB_KEY: &str = r#"-----BEGIN PUBLIC KEY-----
MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAE2G2Y+2tabdTV5BcGiBIx0a9fAFwr
kBbmLSGtks4L3qX6yYY0zufBnhC8Ur/iy55GhWP/9A/bY2LhC30M9+RYtw==
-----END PUBLIC KEY-----"#;

    pub(crate) const FULCIO_CRT_PEM: &str = r#"-----BEGIN CERTIFICATE-----
MIIB+DCCAX6gAwIBAgITNVkDZoCiofPDsy7dfm6geLbuhzAKBggqhkjOPQQDAzAq
MRUwEwYDVQQKEwxzaWdzdG9yZS5kZXYxETAPBgNVBAMTCHNpZ3N0b3JlMB4XDTIx
MDMwNzAzMjAyOVoXDTMxMDIyMzAzMjAyOVowKjEVMBMGA1UEChMMc2lnc3RvcmUu
ZGV2MREwDwYDVQQDEwhzaWdzdG9yZTB2MBAGByqGSM49AgEGBSuBBAAiA2IABLSy
A7Ii5k+pNO8ZEWY0ylemWDowOkNa3kL+GZE5Z5GWehL9/A9bRNA3RbrsZ5i0Jcas
taRL7Sp5fp/jD5dxqc/UdTVnlvS16an+2Yfswe/QuLolRUCrcOE2+2iA5+tzd6Nm
MGQwDgYDVR0PAQH/BAQDAgEGMBIGA1UdEwEB/wQIMAYBAf8CAQEwHQYDVR0OBBYE
FMjFHQBBmiQpMlEk6w2uSu1KBtPsMB8GA1UdIwQYMBaAFMjFHQBBmiQpMlEk6w2u
Su1KBtPsMAoGCCqGSM49BAMDA2gAMGUCMH8liWJfMui6vXXBhjDgY4MwslmN/TJx
Ve/83WrFomwmNf056y1X48F9c4m3a3ozXAIxAKjRay5/aj/jsKKGIkmQatjI8uup
Hr/+CxFvaJWmpYqNkLDGRU+9orzh5hI2RrcuaQ==
-----END CERTIFICATE-----"#;

    pub(crate) fn get_fulcio_public_key() -> Vec<u8> {
        extract_public_key_from_pem_cert(FULCIO_CRT_PEM.as_bytes())
            .expect("Cannot extract public key from Fulcio hard-coded cert")
    }

    pub(crate) fn get_rekor_public_key() -> CosignVerificationKey {
        crypto::new_verification_key(REKOR_PUB_KEY).expect("Cannot create test REKOR_PUB_KEY")
    }

    fn build_test_client(mock_client: MockOciClient) -> Client {
        let rekor_pub_key = crypto::new_verification_key(REKOR_PUB_KEY).unwrap();

        Client {
            registry_client: Box::new(mock_client),
            rekor_pub_key,
            fulcio_pub_key_raw: FULCIO_CRT_PEM.as_bytes().to_vec(),
            cert_email: None,
        }
    }

    #[test]
    fn client_builder_fails_when_rekor_key_is_missing() {
        let client = ClientBuilder::default().build();
        assert!(client.is_err());
    }

    #[tokio::test]
    async fn triangulate_sigstore_object() {
        let image = "docker.io/busybox:latest";
        let image_digest =
            String::from("sha256:f3cfc9d0dbf931d3db4685ec659b7ac68e2a578219da4aae65427886e649b06b");
        let expected_image = "docker.io/busybox:sha256-f3cfc9d0dbf931d3db4685ec659b7ac68e2a578219da4aae65427886e649b06b.sig".parse().unwrap();
        let mock_client = MockOciClient {
            fetch_manifest_digest_response: Some(Ok(image_digest.clone())),
            pull_response: None,
            pull_manifest_response: None,
        };
        let mut cosign_client = build_test_client(mock_client);

        let reference = cosign_client
            .triangulate(image, &crate::registry::Auth::Anonymous)
            .await;

        assert!(reference.is_ok());
        assert_eq!(reference.unwrap(), (expected_image, image_digest));
    }

    #[test]
    fn find_simple_signing_object_when_verification_key_and_no_annotations_are_provided() {
        let (signature_layer, verification_key) = build_correct_signature_layer_without_bundle();
        let source_image_digest = signature_layer
            .simple_signing
            .critical
            .image
            .docker_manifest_digest
            .clone();
        let signature_layers = vec![signature_layer];

        let annotations: HashMap<String, String> = HashMap::new();

        let mock_client = MockOciClient::default();
        let cosign_client = build_test_client(mock_client);

        let actual = cosign_client.find_simple_signing_objects_satisfying_constraints(
            &signature_layers,
            &source_image_digest,
            Some(&verification_key),
            &annotations,
        );
        assert!(!actual.is_empty());
    }

    #[test]
    fn find_simple_signing_object_no_matches_when_no_signature_matches_the_given_key() {
        let (signature_layer, _) = build_correct_signature_layer_without_bundle();
        let source_image_digest = signature_layer
            .simple_signing
            .critical
            .image
            .docker_manifest_digest
            .clone();
        let signature_layers = vec![signature_layer];

        let verification_key = crate::crypto::new_verification_key(
            r#"-----BEGIN PUBLIC KEY-----
MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAELKhD7F5OKy77Z582Y6h0u1J3GNA+
kvUsh4eKpd1lwkDAzfFDs7yXEExsEkPPuiQJBelDT68n7PDIWB/QEY7mrA==
-----END PUBLIC KEY-----"#,
        )
        .unwrap();

        let annotations: HashMap<String, String> = HashMap::new();

        let mock_client = MockOciClient::default();
        let cosign_client = build_test_client(mock_client);

        let actual = cosign_client.find_simple_signing_objects_satisfying_constraints(
            &signature_layers,
            &source_image_digest,
            Some(&verification_key),
            &annotations,
        );
        assert!(actual.is_empty());
    }

    #[test]
    fn find_simple_signing_object_no_matches_when_annotations_are_not_satisfied() {
        let (signature_layer, verification_key) = build_correct_signature_layer_without_bundle();
        let source_image_digest = signature_layer
            .simple_signing
            .critical
            .image
            .docker_manifest_digest
            .clone();
        let signature_layers = vec![signature_layer];

        let mut annotations: HashMap<String, String> = HashMap::new();
        annotations.insert("env".into(), "prod".into());

        let mock_client = MockOciClient::default();
        let cosign_client = build_test_client(mock_client);

        let actual = cosign_client.find_simple_signing_objects_satisfying_constraints(
            &signature_layers,
            &source_image_digest,
            Some(&verification_key),
            &annotations,
        );
        assert!(actual.is_empty());
    }

    #[test]
    fn find_simple_signing_object_no_matches_when_simple_signing_digest_does_not_match_the_expected_one(
    ) {
        let (signature_layer, verification_key) = build_correct_signature_layer_without_bundle();
        let source_image_digest = "this is a different value";
        let signature_layers = vec![signature_layer];

        let annotations: HashMap<String, String> = HashMap::new();

        let mock_client = MockOciClient::default();
        let cosign_client = build_test_client(mock_client);

        let actual = cosign_client.find_simple_signing_objects_satisfying_constraints(
            &signature_layers,
            &source_image_digest,
            Some(&verification_key),
            &annotations,
        );
        assert!(actual.is_empty());
    }

    #[test]
    fn find_simple_signing_object_no_matches_when_no_signature_layer_exists() {
        let source_image_digest = "something";
        let signature_layers: Vec<SignatureLayer> = Vec::new();

        let verification_key = crate::crypto::new_verification_key(
            r#"-----BEGIN PUBLIC KEY-----
MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAELKhD7F5OKy77Z582Y6h0u1J3GNA+
kvUsh4eKpd1lwkDAzfFDs7yXEExsEkPPuiQJBelDT68n7PDIWB/QEY7mrA==
-----END PUBLIC KEY-----"#,
        )
        .unwrap();

        let annotations: HashMap<String, String> = HashMap::new();

        let mock_client = MockOciClient::default();
        let cosign_client = build_test_client(mock_client);

        let actual = cosign_client.find_simple_signing_objects_satisfying_constraints(
            &signature_layers,
            &source_image_digest,
            Some(&verification_key),
            &annotations,
        );
        assert!(actual.is_empty());
    }
}
