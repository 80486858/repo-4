use std::collections::HashMap;

use anyhow::{anyhow, Result};
use ecdsa::signature::Verifier;
use ecdsa::{Signature, VerifyingKey};
use oci_distribution::client::ImageLayer;
use p256::pkcs8::FromPublicKey;
use tracing::{debug, error, info};

use crate::distribution::SIGSTORE_OCI_MEDIA_TYPE;
use crate::simple_signing::SimpleSigning;

pub(crate) type CosignVerificationKey = VerifyingKey<p256::NistP256>;

/// Create a new Cosign Verification Key starting from the contents of
/// a cosign public key.
pub(crate) fn new_verification_key(contents: String) -> Result<CosignVerificationKey> {
    VerifyingKey::<p256::NistP256>::from_public_key_pem(&contents)
        .map_err(|e| anyhow!("Cannot load key: {:?}", e))
}

/// Find all the layers that have been signed with the given key.
/// Return a list of `SimpleSigning` objects that have been signed by
/// the given key
pub(crate) fn verify_layers(
    image_manifest_digest: String,
    layers: Vec<ImageLayer>,
    signatures: HashMap<String, String>,
    annotations: Option<HashMap<String, String>>,
    verification_key: &CosignVerificationKey,
) -> Result<Vec<SimpleSigning>> {
    let mut verified_layers: Vec<SimpleSigning> = Vec::new();
    let annotations = annotations.unwrap_or_default();

    for layer in layers {
        if layer.media_type != SIGSTORE_OCI_MEDIA_TYPE {
            continue;
        }
        let layer_digest = layer.clone().sha256_digest();
        let layer_signature = signatures.get(&layer_digest).ok_or_else(|| {
            anyhow!(
                "Cannot find signature for layer with digest {}",
                layer_digest
            )
        })?;
        if verify_signature(verification_key, layer_signature, &layer.data).is_err() {
            // the given key wasn't used to sign this layer, move on
            info!("skipping layer, it wasn't signed with the given key");
            continue;
        }

        let ss: SimpleSigning = serde_json::from_slice(&layer.data)
            .map_err(|e| anyhow!("Cannot decode Simple Signing data: {:?}", e))?;
        debug!(simple_signing = ?ss);
        if ss.critical.image.docker_manifest_digest != image_manifest_digest {
            let msg = "The image manifest digest does not match with the one reported inside of the Simple Signing metadata";
            error!(
                simple_signing = ?ss,
                expected_manifest_digest = image_manifest_digest.as_str(),
                msg,
            );
            continue;
        }
        if ss.satisfies_annotations(&annotations) {
            verified_layers.push(ss);
        }
    }
    if verified_layers.is_empty() {
        Err(anyhow!(
            "The signature object didn't have any layer signed with the given key"
        ))
    } else {
        Ok(verified_layers)
    }
}

/// Verify the signature provided has been actually generated by the given key against the
/// when signing the provided message.
fn verify_signature(
    verification_key: &CosignVerificationKey,
    signature_str: &str,
    msg: &[u8],
) -> Result<()> {
    let signature_raw = base64::decode(signature_str)?;
    let signature = Signature::<p256::NistP256>::from_der(&signature_raw)?;
    verification_key
        .verify(msg, &signature)
        .map_err(|e| anyhow!("Verification failed: {:?}", e))
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn verify_signature_success() {
        let signature = String::from("MEUCIQD6q/COgzOyW0YH1Dk+CCYSt4uAhm3FDHUwvPI55zwnlwIgE0ZK58ZOWpZw8YVmBapJhBqCfdPekIknimuO0xH8Jh8=");

        let verification_key = new_verification_key(String::from(
            r#"-----BEGIN PUBLIC KEY-----
MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAENptdY/l3nB0yqkXLBWkZWQwo6+cu
OSWS1X9vPavpiQOoTTGC0xX57OojUadxF1cdQmrsiReWg2Wn4FneJfa8xw==
-----END PUBLIC KEY-----"#,
        ))
        .unwrap();

        let msg = r#"{"critical":{"identity":{"docker-reference":"registry-testing.svc.lan/busybox"},"image":{"docker-manifest-digest":"sha256:f3cfc9d0dbf931d3db4685ec659b7ac68e2a578219da4aae65427886e649b06b"},"type":"cosign container image signature"},"optional":null}"#;

        let outcome = verify_signature(&verification_key, &signature, &msg.as_bytes());
        assert!(outcome.is_ok());
    }

    #[test]
    fn verify_signature_failure_because_wrong_msg() {
        let signature = String::from("MEUCIQD6q/COgzOyW0YH1Dk+CCYSt4uAhm3FDHUwvPI55zwnlwIgE0ZK58ZOWpZw8YVmBapJhBqCfdPekIknimuO0xH8Jh8=");

        let verification_key = new_verification_key(String::from(
            r#"-----BEGIN PUBLIC KEY-----
MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAENptdY/l3nB0yqkXLBWkZWQwo6+cu
OSWS1X9vPavpiQOoTTGC0xX57OojUadxF1cdQmrsiReWg2Wn4FneJfa8xw==
-----END PUBLIC KEY-----"#,
        ))
        .unwrap();

        let msg = "hello world";

        let outcome = verify_signature(&verification_key, &signature, &msg.as_bytes());
        assert!(outcome.is_err());
    }

    #[test]
    fn verify_signature_failure_because_wrong_signature() {
        let signature = String::from("this is a signature");

        let verification_key = new_verification_key(String::from(
            r#"-----BEGIN PUBLIC KEY-----
MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAENptdY/l3nB0yqkXLBWkZWQwo6+cu
OSWS1X9vPavpiQOoTTGC0xX57OojUadxF1cdQmrsiReWg2Wn4FneJfa8xw==
-----END PUBLIC KEY-----"#,
        ))
        .unwrap();

        let msg = r#"{"critical":{"identity":{"docker-reference":"registry-testing.svc.lan/busybox"},"image":{"docker-manifest-digest":"sha256:f3cfc9d0dbf931d3db4685ec659b7ac68e2a578219da4aae65427886e649b06b"},"type":"cosign container image signature"},"optional":null}"#;

        let outcome = verify_signature(&verification_key, &signature, &msg.as_bytes());
        assert!(outcome.is_err());
    }

    #[test]
    fn verify_signature_failure_because_wrong_verification_key() {
        let signature = String::from("MEUCIQD6q/COgzOyW0YH1Dk+CCYSt4uAhm3FDHUwvPI55zwnlwIgE0ZK58ZOWpZw8YVmBapJhBqCfdPekIknimuO0xH8Jh8=");

        let verification_key = new_verification_key(String::from(
            r#"-----BEGIN PUBLIC KEY-----
MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAETJP9cqpUQsn2ggmJniWGjHdlsHzD
JsB89BPhZYch0U0hKANx5TY+ncrm0s8bfJxxHoenAEFhwhuXeb4PqIrtoQ==
-----END PUBLIC KEY-----"#,
        ))
        .unwrap();

        let msg = r#"{"critical":{"identity":{"docker-reference":"registry-testing.svc.lan/busybox"},"image":{"docker-manifest-digest":"sha256:f3cfc9d0dbf931d3db4685ec659b7ac68e2a578219da4aae65427886e649b06b"},"type":"cosign container image signature"},"optional":null}"#;

        let outcome = verify_signature(&verification_key, &signature, &msg.as_bytes());
        assert!(outcome.is_err());
    }

    #[test]
    fn verify_layers_success() {
        let image_manifest_digest =
            String::from("sha256:f3cfc9d0dbf931d3db4685ec659b7ac68e2a578219da4aae65427886e649b06b");

        let mut signatures: HashMap<String, String> = HashMap::new();
        signatures.insert(
            String::from("sha256:3af4414d20c9e1cb76ccc72aae8b242166dabe6af531a4a790db8e2f0e5ee7c9"),
            String::from("MEUCIQD6q/COgzOyW0YH1Dk+CCYSt4uAhm3FDHUwvPI55zwnlwIgE0ZK58ZOWpZw8YVmBapJhBqCfdPekIknimuO0xH8Jh8="));

        let verification_key = new_verification_key(String::from(
            r#"-----BEGIN PUBLIC KEY-----
MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAENptdY/l3nB0yqkXLBWkZWQwo6+cu
OSWS1X9vPavpiQOoTTGC0xX57OojUadxF1cdQmrsiReWg2Wn4FneJfa8xw==
-----END PUBLIC KEY-----"#,
        ))
        .unwrap();

        let layer = ImageLayer{
            data: r#"{"critical":{"identity":{"docker-reference":"registry-testing.svc.lan/busybox"},"image":{"docker-manifest-digest":"sha256:f3cfc9d0dbf931d3db4685ec659b7ac68e2a578219da4aae65427886e649b06b"},"type":"cosign container image signature"},"optional":null}"#.into(),
            media_type: String::from(SIGSTORE_OCI_MEDIA_TYPE),
        };
        let layers = vec![layer];

        let outcome = verify_layers(
            image_manifest_digest,
            layers,
            signatures,
            None,
            &verification_key,
        );
        assert!(outcome.is_ok());
    }

    #[test]
    fn verify_layers_failure_because_simple_signature_docker_manifest_digest_does_not_match() {
        let image_manifest_digest = String::from("another sha");

        let mut signatures: HashMap<String, String> = HashMap::new();
        signatures.insert(
            String::from("sha256:3af4414d20c9e1cb76ccc72aae8b242166dabe6af531a4a790db8e2f0e5ee7c9"),
            String::from("MEUCIQD6q/COgzOyW0YH1Dk+CCYSt4uAhm3FDHUwvPI55zwnlwIgE0ZK58ZOWpZw8YVmBapJhBqCfdPekIknimuO0xH8Jh8="));

        let verification_key = new_verification_key(String::from(
            r#"-----BEGIN PUBLIC KEY-----
MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAENptdY/l3nB0yqkXLBWkZWQwo6+cu
OSWS1X9vPavpiQOoTTGC0xX57OojUadxF1cdQmrsiReWg2Wn4FneJfa8xw==
-----END PUBLIC KEY-----"#,
        ))
        .unwrap();

        let layer = ImageLayer{
            data: r#"{"critical":{"identity":{"docker-reference":"registry-testing.svc.lan/busybox"},"image":{"docker-manifest-digest":"sha256:f3cfc9d0dbf931d3db4685ec659b7ac68e2a578219da4aae65427886e649b06b"},"type":"cosign container image signature"},"optional":null}"#.into(),
            media_type: String::from(SIGSTORE_OCI_MEDIA_TYPE),
        };
        let layers = vec![layer];

        let outcome = verify_layers(
            image_manifest_digest,
            layers,
            signatures,
            None,
            &verification_key,
        );
        assert!(outcome.is_err());
    }

    #[test]
    fn verify_layers_failure_because_there_are_no_cosign_layers() {
        let image_manifest_digest =
            String::from("sha256:f3cfc9d0dbf931d3db4685ec659b7ac68e2a578219da4aae65427886e649b06b");

        let mut signatures: HashMap<String, String> = HashMap::new();
        signatures.insert(
            String::from("sha256:3af4414d20c9e1cb76ccc72aae8b242166dabe6af531a4a790db8e2f0e5ee7c9"),
            String::from("MEUCIQD6q/COgzOyW0YH1Dk+CCYSt4uAhm3FDHUwvPI55zwnlwIgE0ZK58ZOWpZw8YVmBapJhBqCfdPekIknimuO0xH8Jh8="));

        let verification_key = new_verification_key(String::from(
            r#"-----BEGIN PUBLIC KEY-----
MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAENptdY/l3nB0yqkXLBWkZWQwo6+cu
OSWS1X9vPavpiQOoTTGC0xX57OojUadxF1cdQmrsiReWg2Wn4FneJfa8xw==
-----END PUBLIC KEY-----"#,
        ))
        .unwrap();

        let layer = ImageLayer{
            data: r#"{"critical":{"identity":{"docker-reference":"registry-testing.svc.lan/busybox"},"image":{"docker-manifest-digest":"sha256:f3cfc9d0dbf931d3db4685ec659b7ac68e2a578219da4aae65427886e649b06b"},"type":"cosign container image signature"},"optional":null}"#.into(),
            media_type: String::from("not-a-cosign-layer"),
        };
        let layers = vec![layer];

        let outcome = verify_layers(
            image_manifest_digest,
            layers,
            signatures,
            None,
            &verification_key,
        );
        assert!(outcome.is_err());
    }

    #[test]
    fn verify_layers_failure_because_there_are_no_layers() {
        let image_manifest_digest =
            String::from("sha256:f3cfc9d0dbf931d3db4685ec659b7ac68e2a578219da4aae65427886e649b06b");

        let mut signatures: HashMap<String, String> = HashMap::new();
        signatures.insert(
            String::from("sha256:3af4414d20c9e1cb76ccc72aae8b242166dabe6af531a4a790db8e2f0e5ee7c9"),
            String::from("MEUCIQD6q/COgzOyW0YH1Dk+CCYSt4uAhm3FDHUwvPI55zwnlwIgE0ZK58ZOWpZw8YVmBapJhBqCfdPekIknimuO0xH8Jh8="));

        let verification_key = new_verification_key(String::from(
            r#"-----BEGIN PUBLIC KEY-----
MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAENptdY/l3nB0yqkXLBWkZWQwo6+cu
OSWS1X9vPavpiQOoTTGC0xX57OojUadxF1cdQmrsiReWg2Wn4FneJfa8xw==
-----END PUBLIC KEY-----"#,
        ))
        .unwrap();

        let layers = vec![];

        let outcome = verify_layers(
            image_manifest_digest,
            layers,
            signatures,
            None,
            &verification_key,
        );
        assert!(outcome.is_err());
    }
}
