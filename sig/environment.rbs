module RBS
  class Environment
    type module_decl = AST::Declarations::Class | AST::Declarations::Module

    interface _ModuleOrClass
      def name: () -> TypeName

      def type_params: () -> Array[AST::TypeParam]
    end

    interface _NamedDecl
      def name: () -> TypeName
    end

    module ContextUtil
      def calculate_context: (Array[_NamedDecl]) -> Resolver::context
    end

    # Name of object, it's (multiple) declarations with the outer module declarations
    #
    class MultiEntry[M < _ModuleOrClass]
      class D[M < _ModuleOrClass]
        attr_reader decl: M
        attr_reader outer: Array[module_decl]

        def initialize: (decl: M, outer: Array[module_decl]) -> void

        include ContextUtil

        @context: Resolver::context

        def context: () -> Resolver::context
      end

      attr_reader name: TypeName
      attr_reader decls: Array[D[M]]

      @primary: D[M]?

      def initialize: (name: TypeName) -> void

      def insert: (decl: M, outer: Array[module_decl]) -> void

      def validate_type_params: () -> void

      def compatible_params?: (Array[AST::TypeParam], Array[AST::TypeParam]) -> boolish

      def type_params: () -> Array[AST::TypeParam]

      def primary: () -> D[M]
    end

    class ModuleEntry < MultiEntry[AST::Declarations::Module]
      def self_types: () -> Array[AST::Declarations::Module::Self]
    end

    class ClassEntry < MultiEntry[AST::Declarations::Class]
    end

    # Name of object, it's (single) declaration, and the outer module declarations
    #
    class SingleEntry[N, D]
      attr_reader name: N
      attr_reader decl: D
      attr_reader outer: Array[module_decl]

      def initialize: (name: N, decl: D, outer: Array[module_decl]) -> void

      include ContextUtil

      @context: Resolver::context

      def context: () -> Resolver::context
    end

    # Top level declarations
    attr_reader declarations: Array[AST::Declarations::t]

    # Class declarations
    attr_reader class_decls: Hash[TypeName, ModuleEntry | ClassEntry]

    # Interface declarations
    attr_reader interface_decls: Hash[TypeName, SingleEntry[TypeName, AST::Declarations::Interface]]

    # Type alias declarations
    attr_reader type_alias_decls: Hash[TypeName, SingleEntry[TypeName, AST::Declarations::TypeAlias]]

    # Constant declarations
    attr_reader constant_decls: Hash[TypeName, SingleEntry[TypeName, AST::Declarations::Constant]]

    # Global declarations
    attr_reader global_decls: Hash[Symbol, SingleEntry[Symbol, AST::Declarations::Global]]

    def initialize: () -> void

    def initialize_copy: (Environment) -> void

    # Construct an environment from EnvironmentLoader
    #
    def self.from_loader: (EnvironmentLoader) -> Environment

    # Insert a toplevel declaration into the environment
    #
    def <<: (AST::Declarations::t decl) -> self

    # Insert a declaration into the environment
    #
    def insert_decl: (AST::Declarations::t, outer: Array[module_decl], namespace: Namespace) -> void

    # Resolve all type names in the environment to absolute type names.
    # Relative type name will be left if absolute type name cannot be found.
    #
    # When `only` is given, it skips other _top-level_ declarations not included in the collection.
    # This helps running resolution faster in the case of _partial updates_.
    #
    def resolve_type_names: (?only: Set[AST::Declarations::t]?) -> Environment

    def inspect: () -> String

    @buffers: Array[Buffer]

    def buffers: () -> Array[Buffer]

    def buffers_decls: () -> Hash[Buffer, Array[AST::Declarations::t]]

    # Construct new environment without declarations tested `true` by block.
    # Construction of new environment is done with `<<` so that nested declarations will work well.
    #
    def reject: () { (AST::Declarations::t) -> boolish } -> Environment

    # Returns true if an interface with the type name is defined
    #
    def interface_name?: (TypeName) -> bool

    # Returns true if a type alias with the type name is defined
    #
    def type_alias_name?: (TypeName) -> bool

    # Returns true if a module or class with the type name is defined
    #
    def module_name?: (TypeName) -> bool

    # Returns true if the type name is defined
    #
    def type_name?: (TypeName) -> bool

    # Returns if a constant of the name is defined
    #
    def constant_name?: (TypeName) -> bool

    # Returns true if the type name is defined by constant declaration
    #
    def constant_decl?: (TypeName) -> bool

    # Returns true if the type name is defined by class declaration
    #
    def class_decl?: (TypeName) -> bool

    # Returns true if the type name is defined by module declaration
    #
    def module_decl?: (TypeName) -> bool

    private

    def cache_name: [N, D] (Hash[N, SingleEntry[N, D]] cache, name: N, decl: D, outer: Array[module_decl]) -> SingleEntry[N, D]

    def resolve_declaration: (Resolver::TypeNameResolver resolver, AST::Declarations::t decl, outer: Array[module_decl], prefix: Namespace) -> AST::Declarations::t

    def resolve_member: (Resolver::TypeNameResolver, AST::Members::t, context: Resolver::context) -> AST::Members::t

    def resolve_method_type: (Resolver::TypeNameResolver, RBS::MethodType, context: Resolver::context) -> RBS::MethodType

    def resolve_type_params: (Resolver::TypeNameResolver resolver, Array[AST::TypeParam], context: Resolver::context) ->  Array[AST::TypeParam]

    # Runs generics type params validation over each class definitions
    def validate_type_params: () -> void

    def absolute_type: (Resolver::TypeNameResolver, Types::t, context: Resolver::context) -> Types::t

    def absolute_type_name: (Resolver::TypeNameResolver, TypeName, context: Resolver::context) -> TypeName
  end
end
